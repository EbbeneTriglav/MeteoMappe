<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Mappa Meteo - San Pellegrino Terme</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Heatmap -->
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

  <!-- D3-Delaunay (per Voronoi) -->
  <script src="https://unpkg.com/d3-delaunay@6/d3-delaunay.min.js"></script>

  <style>
    body { margin:0; font-family: Arial, sans-serif; }
    .map-container { height: 55vh; width: 100%; position: relative; }
    .map-container h3 {
      position: absolute; top: 10px; left: 50px; z-index: 1000;
      background: rgba(255,255,255,0.9); padding: 8px 16px;
      margin: 0; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .controls {
      display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
      padding: 10px 16px; border-bottom: 1px solid #eee;
    }
    .controls label { font-weight: bold; }
    .date-display { min-width: 160px; font-family: monospace; }
    table { border-collapse: collapse; margin: 20px auto; width: 95%; max-width: 1200px; }
    th, td { border: 1px solid #ccc; padding: 6px 8px; text-align: center; font-size: 13px; }
    th { background: #f7f7f7; font-weight: 600; }
    h2 { text-align: center; margin: 20px 0 8px; }
    .loading { text-align: center; padding: 10px; color: #666; }
    .legend { margin: 0 16px 12px 16px; font-size: 13px; color: #444; }
    .model-info { text-align: center; font-size: 12px; color: #666; margin: -10px 0 15px; font-style: italic; }
    .error { color: #d32f2f; text-align: center; padding: 20px; }
    .panel {
      margin: 8px 16px; padding: 8px; border: 1px solid #eee; border-radius: 6px;
      display: flex; flex-wrap: wrap; gap: 10px; align-items: center;
    }
    .panel .group { display: flex; gap: 8px; align-items: center; }
    .legend-bar {
      height: 10px; width: 160px; border: 1px solid #aaa; border-radius: 2px; background: linear-gradient(to right, #f7fbff, #08306b);
    }
    .small { font-size: 12px; color: #555; }
    /* Slider grandi */
    input[type="range"].big {
      -webkit-appearance: none;
      width: 320px; height: 12px; background: #e0e0e0; border-radius: 6px; outline: none;
    }
    input[type="range"].big::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none;
      width: 22px; height: 22px; border-radius: 50%; background: #1976d2; cursor: pointer; border: 2px solid #135ea3;
    }
    input[type="range"].big::-moz-range-thumb {
      width: 22px; height: 22px; border-radius: 50%; background: #1976d2; cursor: pointer; border: 2px solid #135ea3;
    }
    /* Inputs */
    input[type="date"], input[type="time"] { padding: 4px 6px; font-size: 13px; }
    .inline-note { font-size: 12px; color: #666; margin-left: 6px; }
    /* Recap tables container */
    .recap-container { width: 95%; max-width: 1200px; margin: 20px auto; }
    .station-title { font-weight: 700; margin: 16px 0 6px; }
    .year-note { font-size: 12px; color: #666; text-align: right; }
  </style>
</head>
<body>

  <!-- Forecast Map -->
  <div class="map-container">
    <h3>Previsioni Precipitazioni (5 giorni)</h3>
    <div id="mapForecast" style="height: 100%; width: 100%;"></div>
  </div>

  <div class="controls">
    <label for="forecastSlider">Giorno previsione:</label>
    <input id="forecastSlider" class="big" type="range" min="0" max="0" value="0" step="1" />
    <span id="forecastLabel" class="date-display">--</span>
    <span id="forecastRun" class="small">Ultimo aggiornamento API: --</span>
    <span class="legend">Visualizzazione precipitazione giornaliera (mm)</span>
    <label for="forecastDate">Data:</label>
    <input id="forecastDate" type="date" />
    <span class="inline-note">Intervallo:</span>
    <label for="forecastDateStart">Da</label>
    <input id="forecastDateStart" type="date" />
    <label for="forecastDateEnd">A</label>
    <input id="forecastDateEnd" type="date" />
    <span class="inline-note">Somma su intervallo</span>
  </div>

  <div class="panel" id="forecastPanel">
    <div class="group">
      <label for="forecastInterp">Interpolazione:</label>
      <select id="forecastInterp">
        <option value="heat">Heatmap</option>
        <option value="voronoi">Voronoi</option>
      </select>
    </div>
    <div class="group">
      <label for="forecastColor">Scala colore:</label>
      <select id="forecastColor">
        <option value="blues">Blues</option>
        <option value="reds">Reds</option>
        <option value="viridis">Viridis</option>
        <option value="rainbow">Rainbow</option>
      </select>
    </div>
    <div class="group">
      <label for="forecastOpacity">Opacità:</label>
      <input id="forecastOpacity" type="range" min="0" max="1" step="0.05" value="0.7" />
    </div>
    <div class="group">
      <label for="forecastMin">Scala min (mm):</label>
      <input id="forecastMin" type="number" step="0.1" value="0" style="width:80px;" />
    </div>
    <div class="group">
      <label for="forecastMax">Scala max (mm):</label>
      <input id="forecastMax" type="number" step="0.1" value="50" style="width:80px;" />
    </div>
    <div class="group">
      <label for="forecastRadius">Raggio:</label>
      <input id="forecastRadius" type="range" min="10" max="100" step="5" value="45" />
    </div>
    <div class="group">
      <label for="forecastBlur">Blur:</label>
      <input id="forecastBlur" type="range" min="0" max="60" step="2" value="28" />
    </div>
    <div class="group">
      <span>Legenda:</span>
      <div class="legend-bar" id="forecastLegend"></div>
    </div>
  </div>

  <!-- Forecast Table -->
  <h2>Previsioni meteorologiche (5 giorni)</h2>
  <div class="model-info" id="forecastModel">Modello: Open-Meteo (ICON, GFS, ECMWF ensemble)</div>
  <div id="forecastLoading" class="loading">Caricamento previsioni…</div>
  <table id="forecastTable" style="display:none;">
    <thead>
      <tr>
        <th>Data</th>
        <th>Prob. pioggia (%)</th>
        <th>Cumulata (mm)</th>
        <th>Intensità max (mm/h)</th>
        <th>T min (°C)</th>
        <th>T max (°C)</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <!-- History Map (last 10 days) -->
  <div class="map-container">
    <h3>Precipitazioni osservate (ultimi 10 giorni)</h3>
    <div id="mapHistory" style="height: 100%; width: 100%;"></div>
  </div>

  <div class="controls">
    <label for="historySlider">Giorno storico:</label>
    <input id="historySlider" class="big" type="range" min="0" max="0" value="0" step="1" />
    <span id="historyLabel" class="date-display">--</span>
    <span id="historyRun" class="small">Ultimo aggiornamento API: --</span>
    <span class="legend">Visualizzazione precipitazione giornaliera (mm)</span>
    <label for="historyDate">Data:</label>
    <input id="historyDate" type="date" />
    <span class="inline-note">Intervallo:</span>
    <label for="historyDateStart">Da</label>
    <input id="historyDateStart" type="date" />
    <label for="historyDateEnd">A</label>
    <input id="historyDateEnd" type="date" />
    <span class="inline-note">Somma su intervallo</span>
  </div>

  <div class="panel" id="historyPanel">
    <div class="group">
      <label for="historyInterp">Interpolazione:</label>
      <select id="historyInterp">
        <option value="heat">Heatmap</option>
        <option value="voronoi">Voronoi</option>
      </select>
    </div>
    <div class="group">
      <label for="historyColor">Scala colore:</label>
      <select id="historyColor">
        <option value="blues">Blues</option>
        <option value="reds">Reds</option>
        <option value="viridis">Viridis</option>
        <option value="rainbow">Rainbow</option>
      </select>
    </div>
    <div class="group">
      <label for="historyOpacity">Opacità:</label>
      <input id="historyOpacity" type="range" min="0" max="1" step="0.05" value="0.7" />
    </div>
    <div class="group">
      <label for="historyMin">Scala min (mm):</label>
      <input id="historyMin" type="number" step="0.1" value="0" style="width:80px;" />
    </div>
    <div class="group">
      <label for="historyMax">Scala max (mm):</label>
      <input id="historyMax" type="number" step="0.1" value="50" style="width:80px;" />
    </div>
    <div class="group">
      <label for="historyRadius">Raggio:</label>
      <input id="historyRadius" type="range" min="10" max="100" step="5" value="45" />
    </div>
    <div class="group">
      <label for="historyBlur">Blur:</label>
      <input id="historyBlur" type="range" min="0" max="60" step="2" value="28" />
    </div>
    <div class="group">
      <span>Legenda:</span>
      <div class="legend-bar" id="historyLegend"></div>
    </div>
  </div>

  <!-- History Table (last 10 days) -->
  <h2>Dati osservati (ultimi 10 giorni)</h2>
  <div class="model-info">Fonte: Open-Meteo Archive (dati ERA5-Land, CERRA)</div>
  <div id="historyLoading" class="loading">Caricamento storico…</div>
  <table id="historyTable" style="display:none;">
    <thead>
      <tr>
        <th>Data</th>
        <th>Cumulata (mm)</th>
        <th>Intensità max (mm/h)</th>
        <th>T min (°C)</th>
        <th>T max (°C)</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <!-- Annual cumulative precipitation map -->
  <div class="map-container">
    <h3>Precipitazioni cumulative dall'1 gennaio</h3>
    <div id="mapAnnual" style="height: 100%; width: 100%;"></div>
  </div>

  <div class="controls">
    <label for="annualSlider">Data:</label>
    <input id="annualSlider" class="big" type="range" min="0" max="0" value="0" step="1" />
    <span id="annualLabel" class="date-display">--</span>
    <span class="legend">Cumulata (mm) dall'inizio anno</span>
    <label for="annualDate">Data:</label>
    <input id="annualDate" type="date" />
  </div>

  <div class="panel" id="annualPanel">
    <div class="group">
      <label for="annualInterp">Interpolazione:</label>
      <select id="annualInterp">
        <option value="heat">Heatmap</option>
        <option value="voronoi">Voronoi</option>
      </select>
    </div>
    <div class="group">
      <label for="annualColor">Scala colore:</label>
      <select id="annualColor">
        <option value="blues">Blues</option>
        <option value="reds">Reds</option>
        <option value="viridis">Viridis</option>
        <option value="rainbow">Rainbow</option>
      </select>
    </div>
    <div class="group">
      <label for="annualOpacity">Opacità:</label>
      <input id="annualOpacity" type="range" min="0" max="1" step="0.05" value="0.7" />
    </div>
    <div class="group">
      <label for="annualMin">Scala min (mm):</label>
      <input id="annualMin" type="number" step="0.1" value="0" style="width:80px;" />
    </div>
    <div class="group">
      <label for="annualMax">Scala max (mm):</label>
      <input id="annualMax" type="number" step="0.1" value="600" style="width:80px;" />
    </div>
    <div class="group">
      <label for="annualRadius">Raggio:</label>
      <input id="annualRadius" type="range" min="10" max="100" step="5" value="45" />
    </div>
    <div class="group">
      <label for="annualBlur">Blur:</label>
      <input id="annualBlur" type="range" min="0" max="60" step="2" value="28" />
    </div>
    <div class="group">
      <span>Legenda:</span>
      <div class="legend-bar" id="annualLegend"></div>
    </div>
  </div>

  <!-- Maxima map with selectable window and hour intensity -->
  <div class="map-container">
    <h3>Massimi orari dall'1 gennaio (1h / 3h / 6h / 12h) e intensità oraria</h3>
    <div id="mapMaxima" style="height: 100%; width: 100%;"></div>
  </div>

  <div class="controls">
    <label for="maxMode">Modalità:</label>
    <select id="maxMode">
      <option value="window">Max cumulato su finestra</option>
      <option value="hourly">Intensità oraria puntuale</option>
    </select>

    <label for="maxWindow">Finestra:</label>
    <select id="maxWindow">
      <option value="1">1h</option>
      <option value="3">3h</option>
      <option value="6">6h</option>
      <option value="12">12h</option>
      <option value="24">24h</option>
      <option value="48">48h</option>
      <option value="72">72h</option>
    </select>

    <label for="maxSlider">Data/ora:</label>
    <input id="maxSlider" class="big" type="range" min="0" max="0" value="0" step="1" />
    <span id="maxLabel" class="date-display">--</span>
    <span class="legend">Visualizza massimo su finestra o intensità oraria all'istante</span>

    <label for="maxDate">Data:</label>
    <input id="maxDate" type="date" />
    <label for="maxTime">Ora:</label>
    <input id="maxTime" type="time" step="3600" />
  </div>

  <div class="panel" id="maxPanel">
    <div class="group">
      <label for="maxInterp">Interpolazione:</label>
      <select id="maxInterp">
        <option value="heat">Heatmap</option>
        <option value="voronoi">Voronoi</option>
      </select>
    </div>
    <div class="group">
      <label for="maxColor">Scala colore:</label>
      <select id="maxColor">
        <option value="blues">Blues</option>
        <option value="reds">Reds</option>
        <option value="viridis">Viridis</option>
        <option value="rainbow">Rainbow</option>
      </select>
    </div>
    <div class="group">
      <label for="maxOpacity">Opacità:</label>
      <input id="maxOpacity" type="range" min="0" max="1" step="0.05" value="0.7" />
    </div>
    <div class="group">
      <label for="maxMin">Scala min (mm):</label>
      <input id="maxMin" type="number" step="0.1" value="0" style="width:80px;" />
    </div>
    <div class="group">
      <label for="maxMax">Scala max (mm):</label>
      <input id="maxMax" type="number" step="0.1" value="80" style="width:80px;" />
    </div>
    <div class="group">
      <label for="maxRadius">Raggio:</label>
      <input id="maxRadius" type="range" min="10" max="100" step="5" value="45" />
    </div>
    <div class="group">
      <label for="maxBlur">Blur:</label>
      <input id="maxBlur" type="range" min="0" max="60" step="2" value="28" />
    </div>
    <div class="group">
      <span>Legenda:</span>
      <div class="legend-bar" id="maxLegend"></div>
    </div>
  </div>

  <!-- Station recap tables -->
  <h2>Recap stazioni per anno</h2>
  <div class="recap-container">
    <div class="year-note">Intervallo anni: 2022–2025</div>
    <div id="recapLoading" class="loading">Calcolo metriche stazioni…</div>
    <div id="recapTables"></div>
  </div>

  <script>
    // --- Stazioni (lat, lon, quota m) ---
    const locations = {
      "Sussia": [45.833, 9.633, 988],
      "Piazzacava": [45.850, 9.657, 450],
      "Foldone": [45.8491, 9.6161, 1450],
      "Monte Molinasco": [45.854429482557435, 9.64178530454687, 1176],
      "San Pellegrino Terme": [45.848687593657786, 9.666033864451745, 372],
      "Aplecchio": [45.842273445543654, 9.656271242169542, 555],
      "Vettarola": [45.846151165569296, 9.630560511873826, 980],
      "Catremerio": [45.822366845838566, 9.633348279863643, 1023],
      "Cancervo": [45.914712925719755, 9.61825679822863, 1835],
      "Cerro Brembilla": [45.82506049738162, 9.609529281048879, 740],
      "Monte Zucco": [45.821586216612964, 9.65600440296724, 1232],
    };

    // --- Mappe base ---
    const center = [45.8487, 9.6660];
    const mapForecast = L.map('mapForecast').setView(center, 13);
    const mapHistory  = L.map('mapHistory').setView(center, 13);
    const mapAnnual   = L.map('mapAnnual').setView(center, 13);
    const mapMaxima   = L.map('mapMaxima').setView(center, 13);
    [mapForecast, mapHistory, mapAnnual, mapMaxima].forEach(m => {
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18, attribution: '© OpenStreetMap'
      }).addTo(m);
    });

    // Marker stazioni
    const forecastMarkers = {};
    const historyMarkers = {};
    const annualMarkers = {};
    const maxMarkers = {};
    for (let name in locations) {
      const [lat, lon, z] = locations[name];
      forecastMarkers[name] = L.marker([lat, lon]).addTo(mapForecast)
        .bindPopup(`${name} (${z} m)<br/>Cumulata prevista: -- mm`);
      historyMarkers[name] = L.marker([lat, lon]).addTo(mapHistory)
        .bindPopup(`${name} (${z} m)<br/>Cumulata: -- mm`);
      annualMarkers[name] = L.marker([lat, lon]).addTo(mapAnnual)
        .bindPopup(`${name} (${z} m)<br/>Cumulata A.Y.: -- mm`);
      maxMarkers[name] = L.marker([lat, lon]).addTo(mapMaxima)
        .bindPopup(`${name} (${z} m)<br/>Valore: -- mm`);
    }

    // --- Utility date ---
    function toISODate(d) { return d.toISOString().split('T')[0]; }
    function fmt(val, digits=1) {
      if (val === null || val === undefined || Number.isNaN(Number(val))) return "--";
      return Number(val).toFixed(digits);
    }
    function startOfYear(date) { return new Date(date.getFullYear(), 0, 1); }
    function parseISODate(s) { const [y,m,d]=s.split('-').map(Number); return new Date(y, m-1, d); }

    // --- Finestra temporale per storico breve (ultimi 10 giorni) ---
    const today = new Date();
    const startHist = new Date(today); startHist.setDate(today.getDate() - 11); // include 10 giorni completi prima di ieri
    const endHist = new Date(today); endHist.setDate(today.getDate() - 1);

    // --- Finestra temporale annuale ---
    const startYear = startOfYear(today);
    const endYear = endHist; // fino a ieri per allineare con dati archivio

    // --- Color scales ---
    function colorScale(name, t) {
      const clamp = (x)=>Math.max(0,Math.min(1,x));
      t = clamp(t);
      switch(name) {
        case 'reds':   return `rgb(${Math.round(255*t)}, ${Math.round(50*(1-t))}, ${Math.round(50*(1-t))})`;
        case 'blues':  return `rgb(${Math.round(50*(1-t))}, ${Math.round(140*(1-t))}, ${Math.round(255*t)})`;
        case 'viridis':{
          const r = Math.round(68 + 187*t);
          const g = Math.round(1 + 195*t);
          const b = Math.round(84 + 70*t);
          return `rgb(${r},${g},${b})`;
        }
        case 'rainbow':{
          const h = Math.round(240*(1-t));
          return `hsl(${h}, 90%, 50%)`;
        }
        default: return `rgb(${Math.round(50*(1-t))}, ${Math.round(140*(1-t))}, ${Math.round(255*t)})`;
      }
    }
    function updateLegendBar(el, name) {
      const gradStops = [];
      for (let i=0;i<=10;i++) {
        const t = i/10;
        gradStops.push(`${colorScale(name,t)} ${t*100}%`);
      }
      el.style.background = `linear-gradient(to right, ${gradStops.join(',')})`;
    }

    // --- Interpolazione Voronoi su Leaflet ---
    function renderVoronoi(map, points, values, minVal, maxVal, colorName, opacity, layerRefHolder) {
      if (layerRefHolder.layer) { map.removeLayer(layerRefHolder.layer); layerRefHolder.layer = null; }
      const projected = points.map(p => map.latLngToLayerPoint([p.lat, p.lon]));
      const coords = projected.map(pp => [pp.x, pp.y]);
      if (coords.length < 3) {
        const group = L.layerGroup();
        points.forEach((p,i) => {
          const t = (values[i]-minVal)/(maxVal-minVal || 1);
          const color = colorScale(colorName, Math.max(0,Math.min(1,t)));
          const circle = L.circle([p.lat, p.lon], {radius: 150, color: color, fillColor: color, fillOpacity: opacity, weight: 0.5});
          group.addLayer(circle);
        });
        group.addTo(map);
        layerRefHolder.layer = group;
        return;
      }
      const delaunay = d3.Delaunay.from(coords);
      const vor = delaunay.voronoi([0,0, map.getSize().x, map.getSize().y]);
      const group = L.layerGroup();
      for (let i=0;i<coords.length;i++) {
        const path = vor.cellPolygon(i);
        if (!path) continue;
        const latlngs = path.map(([x,y]) => map.layerPointToLatLng(L.point(x,y)));
        const t = (values[i]-minVal)/(maxVal-minVal || 1);
        const color = colorScale(colorName, Math.max(0,Math.min(1,t)));
        const poly = L.polygon(latlngs, {color: color, weight: 0, fillColor: color, fillOpacity: opacity});
        group.addLayer(poly);
      }
      group.addTo(map);
      layerRefHolder.layer = group;
    }

    // --- Heat rendering helper (normalized intensities) ---
    function renderHeat(map, points, values, minVal, maxVal, radius, blur, opacity, layerRefHolder) {
      if (layerRefHolder.layer) { map.removeLayer(layerRefHolder.layer); layerRefHolder.layer = null; }
      const span = (maxVal - minVal) || 1;
      const heatPoints = points.map((p,i) => {
        const v = (values[i] - minVal) / span;
        return [p.lat, p.lon, Math.max(0, Math.min(1, v))];
      });
      const heat = L.heatLayer(heatPoints, { radius, blur, maxZoom: 13, opacity });
      heat.addTo(map);
      layerRefHolder.layer = heat;
    }

    // --- Fetch helper con ultimo aggiornamento (Date header) ---
    async function fetchJsonWithDate(url) {
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const lastDate = resp.headers.get('Date');
      const json = await resp.json();
      return { json, lastDate };
    }

    // --- Fetch dati Open-Meteo per una località ---
    async function fetchForLocation(lat, lon) {
      const forecastUrl =
        `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}` +
        `&daily=precipitation_sum,precipitation_probability_max,precipitation_hours,temperature_2m_min,temperature_2m_max` +
        `&hourly=precipitation` +
        `&timezone=Europe/Rome&forecast_days=5`;

      const historyUrl =
        `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}` +
        `&start_date=${toISODate(startHist)}&end_date=${toISODate(endHist)}` +
        `&daily=precipitation_sum,temperature_2m_min,temperature_2m_max` +
        `&hourly=precipitation` +
        `&timezone=Europe/Rome`;

      const [{json: forecast, lastDate: forecastLast}, {json: history, lastDate: historyLast}] =
        await Promise.all([fetchJsonWithDate(forecastUrl), fetchJsonWithDate(historyUrl)]);

      return { forecast, history, forecastLast, historyLast };
    }

    // --- Fetch annual archive (dall'1 gennaio) per località ---
    async function fetchAnnualForLocation(lat, lon) {
      const url =
        `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}` +
        `&start_date=${toISODate(startYear)}&end_date=${toISODate(endYear)}` +
        `&daily=precipitation_sum` +
        `&hourly=precipitation` +
        `&timezone=Europe/Rome`;
      const { json, lastDate } = await fetchJsonWithDate(url);
      return { annual: json, annualLast: lastDate };
    }

    // --- Fetch per recap annuale per anno intero ---
    async function fetchYearForLocation(lat, lon, year) {
      const start = `${year}-01-01`;
      const end = `${year}-12-31`;
      const url =
        `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}` +
        `&start_date=${start}&end_date=${end}` +
        `&daily=precipitation_sum` +
        `&hourly=precipitation` +
        `&timezone=Europe/Rome`;
      const { json } = await fetchJsonWithDate(url);
      return json;
    }

    // --- Calcola max precipitazione oraria per giorno i ---
    function calcMaxHourlyPrecip(hourlyData, dayIndex) {
      if (!hourlyData || !hourlyData.precipitation || !hourlyData.time) return 0;
      const targetDate = hourlyData.time[dayIndex * 24]?.split('T')[0];
      let maxPrecip = 0;
      hourlyData.time.forEach((timeStr, i) => {
        const date = timeStr.split('T')[0];
        if (date === targetDate) {
          const precip = Number(hourlyData.precipitation[i] || 0);
          if (precip > maxPrecip) maxPrecip = precip;
        }
      });
      return maxPrecip;
    }

    // --- Rolling window max fino a indice ---
    function calcMaxWindow(hourlyData, windowHours, uptoIndexInclusive) {
      if (!hourlyData || !hourlyData.precipitation || !hourlyData.time) return 0;
      const arr = hourlyData.precipitation.slice(0, uptoIndexInclusive + 1).map(x => Number(x || 0));
      const w = Number(windowHours);
      if (arr.length === 0 || w <= 0) return 0;
      let best = 0, sum = 0;
      let q = [];
      for (let i=0;i<arr.length;i++) {
        q.push(arr[i]);
        sum += arr[i];
        if (q.length > w) { sum -= q.shift(); }
        if (q.length === w && sum > best) best = sum;
      }
      return best;
    }

    // --- Rolling window max su un intero array ---
    function calcMaxWindowFull(arr, w) {
      if (!arr || arr.length === 0 || w <= 0) return 0;
      let best = 0, sum = 0;
      let q = [];
      for (let i=0;i<arr.length;i++) {
        q.push(arr[i]);
        sum += arr[i];
        if (q.length > w) { sum -= q.shift(); }
        if (q.length === w && sum > best) best = sum;
      }
      return best;
    }

    // --- Aggregazione e rendering ---
    async function loadAll() {
      const forecastAgg = {};
      const historyAgg = {};
      const forecastByDay = {};
      const historyByDay = {};
      const forecastPerStation = {};
      const historyPerStation = {};

      const annualDailyByStation = {};  // {name: {dateStr: dailySum}}
      const annualHourlyByStation = {}; // {name: {timeStr: hourly}}
      let forecastLastGlobal = null;
      let historyLastGlobal = null;
      let annualLastGlobal = null;

      let successCount = 0;
      let errorCount = 0;

      let annualDatesSet = new Set();
      let annualTimes = [];

      for (let name in locations) {
        const [lat, lon] = locations[name];
        try {
          const dataFH = await fetchForLocation(lat, lon);
          successCount++;

          if (!forecastLastGlobal && dataFH.forecastLast) forecastLastGlobal = dataFH.forecastLast;
          if (!historyLastGlobal && dataFH.historyLast) historyLastGlobal = dataFH.historyLast;

          // FORECAST
          const f = dataFH.forecast?.daily;
          const fHourly = dataFH.forecast?.hourly;
          if (f && f.time) {
            f.time.forEach((d, i) => {
              if (!forecastAgg[d]) forecastAgg[d] = { prob:0, sum:0, max:0, tmin:0, tmax:0, count:0 };
              forecastAgg[d].prob += Number(f.precipitation_probability_max?.[i] ?? 0);
              forecastAgg[d].sum  += Number(f.precipitation_sum?.[i] ?? 0);
              forecastAgg[d].tmin += Number(f.temperature_2m_min?.[i] ?? 0);
              forecastAgg[d].tmax += Number(f.temperature_2m_max?.[i] ?? 0);
              const maxHourly = calcMaxHourlyPrecip(fHourly, i);
              forecastAgg[d].max += maxHourly;
              forecastAgg[d].count++;

              if (!forecastByDay[d]) forecastByDay[d] = [];
              forecastByDay[d].push({ lat, lon, value: Number(f.precipitation_sum?.[i] ?? 0) });

              if (!forecastPerStation[d]) forecastPerStation[d] = {};
              forecastPerStation[d][name] = {
                sum: Number(f.precipitation_sum?.[i] ?? 0),
                max: maxHourly
              };
            });
          }

          // HISTORY
          const h = dataFH.history?.daily;
          const hHourly = dataFH.history?.hourly;
          if (h && h.time) {
            h.time.forEach((d, i) => {
              const sum = Number(h.precipitation_sum?.[i] ?? 0);
              const tmin = Number(h.temperature_2m_min?.[i] ?? 0);
              const tmax = Number(h.temperature_2m_max?.[i] ?? 0);
              const maxHourly = calcMaxHourlyPrecip(hHourly, i);

              if (!historyAgg[d]) historyAgg[d] = { sum:0, max:0, tmin:0, tmax:0, count:0 };
              historyAgg[d].sum += sum;
              historyAgg[d].max += maxHourly;
              historyAgg[d].tmin += tmin;
              historyAgg[d].tmax += tmax;
              historyAgg[d].count++;

              if (!historyByDay[d]) historyByDay[d] = [];
              historyByDay[d].push({ lat, lon, value: sum });

              if (!historyPerStation[d]) historyPerStation[d] = {};
              historyPerStation[d][name] = { sum, max: maxHourly };
            });
          }

          // ANNUALE
          const { annual, annualLast } = await fetchAnnualForLocation(lat, lon);
          if (!annualLastGlobal && annualLast) annualLastGlobal = annualLast;

          const aDaily = {};
          (annual?.daily?.time || []).forEach((d, i) => {
            const v = Number(annual?.daily?.precipitation_sum?.[i] ?? 0);
            aDaily[d] = v;
            annualDatesSet.add(d);
          });
          annualDailyByStation[name] = aDaily;

          const aHourly = {};
          const times = annual?.hourly?.time || [];
          const precs = annual?.hourly?.precipitation || [];
          times.forEach((t, i) => { aHourly[t] = Number(precs[i] ?? 0); });
          annualHourlyByStation[name] = aHourly;
          if (annualTimes.length === 0) annualTimes = times.slice();

        } catch (e) {
          console.warn("Errore fetch", name, e);
          errorCount++;
        }
      }

      console.log(`Caricamento completato: ${successCount} località OK, ${errorCount} errori`);
      if (successCount === 0) throw new Error("Impossibile caricare dati da nessuna località");

      // --- Popola tabella FORECAST ---
      const fTbody = document.querySelector("#forecastTable tbody");
      const fLoading = document.getElementById("forecastLoading");
      const fTable = document.getElementById("forecastTable");
      const forecastDates = Object.keys(forecastAgg).sort();

      forecastDates.forEach(d => {
        const row = forecastAgg[d];
        const probAvg = row.count ? (row.prob / row.count) : 0;
        const sumAvg  = row.count ? (row.sum / row.count) : 0;
        const maxAvg  = row.count ? (row.max / row.count) : 0;
        const tminAvg = row.count ? (row.tmin / row.count) : null;
        const tmaxAvg = row.count ? (row.tmax / row.count) : null;
        fTbody.insertAdjacentHTML("beforeend",
          `<tr>
            <td>${d}</td>
            <td>${fmt(probAvg,0)}</td>
            <td>${fmt(sumAvg,1)}</td>
            <td>${fmt(maxAvg,1)}</td>
            <td>${fmt(tminAvg,1)}</td>
            <td>${fmt(tmaxAvg,1)}</td>
          </tr>`);
      });
      fLoading.style.display = "none";
      fTable.style.display = "";
      document.getElementById("forecastRun").textContent =
        `Ultimo aggiornamento API: ${forecastLastGlobal || '--'}`;

      // --- Popola tabella HISTORY ---
      const hTbody = document.querySelector("#historyTable tbody");
      const hLoading = document.getElementById("historyLoading");
      const hTable = document.getElementById("historyTable");
      const historyDates = Object.keys(historyAgg).sort();

      historyDates.forEach(d => {
        const row = historyAgg[d];
        const sumAvg = row.count ? (row.sum / row.count) : 0;
        const maxAvg = row.count ? (row.max / row.count) : 0;
        const tminAvg = row.count ? (row.tmin / row.count) : null;
        const tmaxAvg = row.count ? (row.tmax / row.count) : null;
        hTbody.insertAdjacentHTML("beforeend",
          `<tr>
            <td>${d}</td>
            <td>${fmt(sumAvg,1)}</td>
            <td>${fmt(maxAvg,1)}</td>
            <td>${fmt(tminAvg,1)}</td>
            <td>${fmt(tmaxAvg,1)}</td>
          </tr>`);
      });
      hLoading.style.display = "none";
      hTable.style.display = "";
      document.getElementById("historyRun").textContent =
        `Ultimo aggiornamento API: ${historyLastGlobal || '--'}`;

      // --- Setup sliders & date pickers ---
      const forecastSlider = document.getElementById("forecastSlider");
      const forecastLabel = document.getElementById("forecastLabel");
      const forecastDate = document.getElementById("forecastDate");
      const forecastDateStart = document.getElementById("forecastDateStart");
      const forecastDateEnd = document.getElementById("forecastDateEnd");
      forecastSlider.min = 0;
      forecastSlider.max = Math.max(0, forecastDates.length - 1);
      forecastSlider.value = 0;
      forecastDate.min = forecastDates[0] || "";
      forecastDate.max = forecastDates[forecastDates.length-1] || "";
      forecastDateStart.min = forecastDate.min; forecastDateStart.max = forecastDate.max;
      forecastDateEnd.min = forecastDate.min;   forecastDateEnd.max = forecastDate.max;

      const historySlider = document.getElementById("historySlider");
      const historyLabel = document.getElementById("historyLabel");
      const historyDate = document.getElementById("historyDate");
      const historyDateStart = document.getElementById("historyDateStart");
      const historyDateEnd = document.getElementById("historyDateEnd");
      historySlider.min = 0;
      historySlider.max = Math.max(0, historyDates.length - 1);
      historySlider.value = historySlider.max;
      historyDate.min = historyDates[0] || "";
      historyDate.max = historyDates[historyDates.length-1] || "";
      historyDateStart.min = historyDate.min; historyDateStart.max = historyDate.max;
      historyDateEnd.min = historyDate.min;   historyDateEnd.max = historyDate.max;

      const annualDates = Array.from(annualDatesSet).sort();
      const annualSlider = document.getElementById("annualSlider");
      const annualLabel  = document.getElementById("annualLabel");
      const annualDate   = document.getElementById("annualDate");
      annualSlider.min = 0;
      annualSlider.max = Math.max(0, annualDates.length - 1);
      annualSlider.value = annualSlider.max;
      annualLabel.textContent = annualDates[annualSlider.value] || '--';
      annualDate.min = annualDates[0] || "";
      annualDate.max = annualDates[annualDates.length-1] || "";

      const maxSlider = document.getElementById("maxSlider");
      const maxLabel  = document.getElementById("maxLabel");
      const maxDate   = document.getElementById("maxDate");
      const maxTime   = document.getElementById("maxTime");
      const maxMode   = document.getElementById("maxMode");
      maxSlider.min = 0;
      maxSlider.max = Math.max(0, annualTimes.length - 1);
      maxSlider.value = maxSlider.max;
      maxLabel.textContent = (annualTimes[maxSlider.value] || '--').replace('T', ' ');
      // set bounds for date/time pickers
      if (annualTimes.length) {
        const firstDT = annualTimes[0].split('T');
        const lastDT  = annualTimes[annualTimes.length-1].split('T');
        maxDate.min = firstDT[0]; maxDate.max = lastDT[0];
        maxTime.value = lastDT[1] || "00:00";
      }

      // --- Controls references & legends ---
      const forecastInterp = document.getElementById("forecastInterp");
      const forecastColor  = document.getElementById("forecastColor");
      const forecastOpacity= document.getElementById("forecastOpacity");
      const forecastMin    = document.getElementById("forecastMin");
      const forecastMax    = document.getElementById("forecastMax");
      const forecastRadius = document.getElementById("forecastRadius");
      const forecastBlur   = document.getElementById("forecastBlur");
      const forecastLegend = document.getElementById("forecastLegend");

      const historyInterp = document.getElementById("historyInterp");
      const historyColor  = document.getElementById("historyColor");
      const historyOpacity= document.getElementById("historyOpacity");
      const historyMin    = document.getElementById("historyMin");
      const historyMax    = document.getElementById("historyMax");
      const historyRadius = document.getElementById("historyRadius");
      const historyBlur   = document.getElementById("historyBlur");
      const historyLegend = document.getElementById("historyLegend");

      const annualInterp = document.getElementById("annualInterp");
      const annualColor  = document.getElementById("annualColor");
      const annualOpacity= document.getElementById("annualOpacity");
      const annualMin    = document.getElementById("annualMin");
      const annualMax    = document.getElementById("annualMax");
      const annualRadius = document.getElementById("annualRadius");
      const annualBlur   = document.getElementById("annualBlur");
      const annualLegend = document.getElementById("annualLegend");

      const maxInterp = document.getElementById("maxInterp");
      const maxColor  = document.getElementById("maxColor");
      const maxOpacity= document.getElementById("maxOpacity");
      const maxMin    = document.getElementById("maxMin");
      const maxMax    = document.getElementById("maxMax");
      const maxRadius = document.getElementById("maxRadius");
      const maxBlur   = document.getElementById("maxBlur");
      const maxLegend = document.getElementById("maxLegend");
      const maxWindow = document.getElementById("maxWindow");

      updateLegendBar(forecastLegend, forecastColor.value);
      updateLegendBar(historyLegend, historyColor.value);
      updateLegendBar(annualLegend, annualColor.value);
      updateLegendBar(maxLegend, maxColor.value);

      // --- Layer refs ---
      const forecastLayerRef = { layer: null };
      const historyLayerRef  = { layer: null };
      const annualLayerRef   = { layer: null };
      const maxLayerRef      = { layer: null };

      // --- Helpers per somma su intervallo (daily series) ---
      function sumInterval(seriesArray, dates, start, end) {
        if (!start || !end) return null;
        const startIdx = dates.indexOf(start);
        const endIdx   = dates.indexOf(end);
        if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) return null;
        const res = [];
        for (let i=0;i<seriesArray.length;i++) {
          const v = seriesArray[i].slice(startIdx, endIdx+1).reduce((a,b)=>a+Number(b||0), 0);
          res.push(v);
        }
        return res;
      }

      // --- Update functions ---
      function updateForecast(idxOrDate=null, intervalMode=false) {
        let date = null;
        if (intervalMode) {
          const ds = forecastDateStart.value;
          const de = forecastDateEnd.value;
          forecastLabel.textContent = ds && de ? `${ds} → ${de}` : "--";
          const pts = [];
          const vals = [];
          // costruisci array di somme su intervallo per ogni stazione
          const allDates = forecastDates;
          for (let name in locations) {
            // per ricavare la daily per stazione, usiamo forecastPerStation
            const series = allDates.map(d => (forecastPerStation[d]?.[name]?.sum) ?? 0);
            const sumVal = sumInterval([series], allDates, ds, de);
            const [lat, lon] = locations[name];
            pts.push({lat, lon});
            vals.push(sumVal ? sumVal[0] : 0);
            forecastMarkers[name].setPopupContent(`${name} (${locations[name][2]} m)<br/>Cumulata prevista intervallo: ${fmt(sumVal ? sumVal[0] : 0,1)} mm`);
          }
          const minV = Number(forecastMin.value);
          const maxV = Number(forecastMax.value);
          const opacity = Number(forecastOpacity.value);
          const radius = Number(forecastRadius.value);
          const blur = Number(forecastBlur.value);
          const colorName = forecastColor.value;
          updateLegendBar(forecastLegend, colorName);
          if (forecastInterp.value === 'voronoi') {
            renderVoronoi(mapForecast, pts, vals, minV, maxV, colorName, opacity, forecastLayerRef);
          } else {
            renderHeat(mapForecast, pts, vals, minV, maxV, radius, blur, opacity, forecastLayerRef);
          }
          return;
        }

        if (typeof idxOrDate === "string") {
          date = idxOrDate;
          const idx = forecastDates.indexOf(date);
          if (idx !== -1) forecastSlider.value = idx;
        } else {
          date = forecastDates[idxOrDate ?? Number(forecastSlider.value)];
        }

        forecastLabel.textContent = date ?? "--";
        const pts = (forecastByDay[date] || []).map(p => ({lat:p.lat, lon:p.lon}));
        const vals = (forecastByDay[date] || []).map(p => p.value);
        const minV = Number(forecastMin.value);
        const maxV = Number(forecastMax.value);
        const opacity = Number(forecastOpacity.value);
        const radius = Number(forecastRadius.value);
        const blur = Number(forecastBlur.value);
        const colorName = forecastColor.value;
        updateLegendBar(forecastLegend, colorName);
        if (forecastInterp.value === 'voronoi') {
          renderVoronoi(mapForecast, pts, vals, minV, maxV, colorName, opacity, forecastLayerRef);
        } else {
          renderHeat(mapForecast, pts, vals, minV, maxV, radius, blur, opacity, forecastLayerRef);
        }
        const perStation = forecastPerStation[date] ?? {};
        for (let name in forecastMarkers) {
          const val = perStation[name]?.sum ?? null;
          const txt = fmt(val, 1);
          const z = locations[name][2];
          forecastMarkers[name].setPopupContent(`${name} (${z} m)<br/>Cumulata prevista: ${txt} mm`);
        }
      }

      function updateHistory(idxOrDate=null, intervalMode=false) {
        let date = null;
        if (intervalMode) {
          const ds = historyDateStart.value;
          const de = historyDateEnd.value;
          historyLabel.textContent = ds && de ? `${ds} → ${de}` : "--";
          const pts = [];
          const vals = [];
          const allDates = historyDates;
          for (let name in locations) {
            const series = allDates.map(d => (historyPerStation[d]?.[name]?.sum) ?? 0);
            const sumVal = sumInterval([series], allDates, ds, de);
            const [lat, lon] = locations[name];
            pts.push({lat, lon});
            vals.push(sumVal ? sumVal[0] : 0);
            historyMarkers[name].setPopupContent(`${name} (${locations[name][2]} m)<br/>Cumulata intervallo: ${fmt(sumVal ? sumVal[0] : 0,1)} mm`);
          }
          const minV = Number(historyMin.value);
          const maxV = Number(historyMax.value);
          const opacity = Number(historyOpacity.value);
          const radius = Number(historyRadius.value);
          const blur = Number(historyBlur.value);
          const colorName = historyColor.value;
          updateLegendBar(historyLegend, colorName);
          if (historyInterp.value === 'voronoi') {
            renderVoronoi(mapHistory, pts, vals, minV, maxV, colorName, opacity, historyLayerRef);
          } else {
            renderHeat(mapHistory, pts, vals, minV, maxV, radius, blur, opacity, historyLayerRef);
          }
          return;
        }

        if (typeof idxOrDate === "string") {
          date = idxOrDate;
          const idx = historyDates.indexOf(date);
          if (idx !== -1) historySlider.value = idx;
        } else {
          date = historyDates[idxOrDate ?? Number(historySlider.value)];
        }

        historyLabel.textContent = date ?? "--";
        const pts = (historyByDay[date] || []).map(p => ({lat:p.lat, lon:p.lon}));
        const vals = (historyByDay[date] || []).map(p => p.value);
        const minV = Number(historyMin.value);
        const maxV = Number(historyMax.value);
        const opacity = Number(historyOpacity.value);
        const radius = Number(historyRadius.value);
        const blur = Number(historyBlur.value);
        const colorName = historyColor.value;
        updateLegendBar(historyLegend, colorName);
        if (historyInterp.value === 'voronoi') {
          renderVoronoi(mapHistory, pts, vals, minV, maxV, colorName, opacity, historyLayerRef);
        } else {
          renderHeat(mapHistory, pts, vals, minV, maxV, radius, blur, opacity, historyLayerRef);
        }
        const perStation = historyPerStation[date] ?? {};
        for (let name in historyMarkers) {
          const val = perStation[name]?.sum ?? null;
          const txt = fmt(val, 1);
          const z = locations[name][2];
          historyMarkers[name].setPopupContent(`${name} (${z} m)<br/>Cumulata: ${txt} mm`);
        }
      }

      function updateAnnual(idxOrDate=null) {
        let date = null;
        if (typeof idxOrDate === "string") {
          date = idxOrDate;
          const idx = annualDates.indexOf(date);
          if (idx !== -1) annualSlider.value = idx;
        } else {
          date = annualDates[idxOrDate ?? Number(annualSlider.value)];
        }

        annualLabel.textContent = date ?? "--";
        const pts = [];
        const vals = [];
        for (let name in annualDailyByStation) {
          const series = annualDailyByStation[name];
          let cum = 0;
          for (let d of annualDates) {
            cum += Number(series[d] || 0);
            if (d === date) break;
          }
          const [lat, lon] = locations[name];
          pts.push({ lat, lon });
          vals.push(cum);
          annualMarkers[name].setPopupContent(`${name} (${locations[name][2]} m)<br/>Cumulata A.Y. a ${date}: ${fmt(cum,1)} mm`);
        }
        const minV = Number(annualMin.value);
        const maxV = Number(annualMax.value);
        const opacity = Number(annualOpacity.value);
        const radius = Number(annualRadius.value);
        const blur = Number(annualBlur.value);
        const colorName = annualColor.value;
        updateLegendBar(annualLegend, colorName);
        if (annualInterp.value === 'voronoi') {
          renderVoronoi(mapAnnual, pts, vals, minV, maxV, colorName, opacity, annualLayerRef);
        } else {
          renderHeat(mapAnnual, pts, vals, minV, maxV, radius, blur, opacity, annualLayerRef);
        }
      }

      function updateMaxima(idx=null, windowHours=null, mode=null) {
        const currentMode = mode || maxMode.value;
        const idxVal = idx ?? Number(maxSlider.value);
        const timeStr = annualTimes[idxVal]; // 'YYYY-MM-DDTHH:MM'
        const dateStr = timeStr ? timeStr.split('T')[0] : '--';
        const hourStr = timeStr ? timeStr.split('T')[1] : '';
        maxLabel.textContent = timeStr ? `${dateStr} ${hourStr}` : '--';

        const pts = [];
        const vals = [];
        for (let name in annualHourlyByStation) {
          const series = annualHourlyByStation[name];
          const arr = annualTimes.map(t => Number(series[t] || 0));
          let value = 0;
          if (currentMode === 'window') {
            const maxWin = calcMaxWindow({ precipitation: arr, time: annualTimes }, Number(windowHours || maxWindow.value), idxVal);
            value = maxWin;
            maxMarkers[name].setPopupContent(`${name} (${locations[name][2]} m)<br/>Max ${Number(windowHours || maxWindow.value)}h fino a ${dateStr} ${hourStr}: ${fmt(value,1)} mm`);
          } else {
            // Intensità oraria puntuale
            const v = arr[idxVal] || 0;
            value = v;
            maxMarkers[name].setPopupContent(`${name} (${locations[name][2]} m)<br/>Intensità oraria ${dateStr} ${hourStr}: ${fmt(value,1)} mm/h`);
          }
          const [lat, lon] = locations[name];
          pts.push({ lat, lon });
          vals.push(value);
        }

        const minV = Number(maxMin.value);
        const maxV = Number(maxMax.value);
        const opacity = Number(maxOpacity.value);
        const radius = Number(maxRadius.value);
        const blur = Number(maxBlur.value);
        const colorName = maxColor.value;
        updateLegendBar(maxLegend, colorName);
        if (maxInterp.value === 'voronoi') {
          renderVoronoi(mapMaxima, pts, vals, minV, maxV, colorName, opacity, maxLayerRef);
        } else {
          renderHeat(mapMaxima, pts, vals, minV, maxV, radius, blur, opacity, maxLayerRef);
        }
      }

      // --- Event listeners ---
      forecastSlider.addEventListener("input", () => updateForecast(Number(forecastSlider.value)));
      forecastDate.addEventListener("change", () => {
        const d = forecastDate.value;
        if (d) updateForecast(d);
      });
      function refreshForecastInterval() {
        const ds = forecastDateStart.value;
        const de = forecastDateEnd.value;
        if (ds && de) updateForecast(null, true);
      }
      forecastDateStart.addEventListener("change", refreshForecastInterval);
      forecastDateEnd.addEventListener("change", refreshForecastInterval);
      [forecastInterp, forecastColor, forecastOpacity, forecastMin, forecastMax, forecastRadius, forecastBlur]
        .forEach(el => el.addEventListener('input', () => {
          const ds = forecastDateStart.value, de = forecastDateEnd.value;
          if (ds && de) updateForecast(null, true);
          else updateForecast(Number(forecastSlider.value));
        }));

      historySlider.addEventListener("input", () => updateHistory(Number(historySlider.value)));
      historyDate.addEventListener("change", () => {
        const d = historyDate.value;
        if (d) updateHistory(d);
      });
      function refreshHistoryInterval() {
        const ds = historyDateStart.value;
        const de = historyDateEnd.value;
        if (ds && de) updateHistory(null, true);
      }
      historyDateStart.addEventListener("change", refreshHistoryInterval);
      historyDateEnd.addEventListener("change", refreshHistoryInterval);
      [historyInterp, historyColor, historyOpacity, historyMin, historyMax, historyRadius, historyBlur]
        .forEach(el => el.addEventListener('input', () => {
          const ds = historyDateStart.value, de = historyDateEnd.value;
          if (ds && de) updateHistory(null, true);
          else updateHistory(Number(historySlider.value));
        }));

      annualSlider.addEventListener("input", () => updateAnnual(Number(annualSlider.value)));
      annualDate.addEventListener("change", () => {
        const d = annualDate.value;
        if (d) updateAnnual(d);
      });
      [annualInterp, annualColor, annualOpacity, annualMin, annualMax, annualRadius, annualBlur]
        .forEach(el => el.addEventListener('input', () => updateAnnual(Number(annualSlider.value))));

      function refreshMax() { updateMaxima(Number(maxSlider.value), Number(maxWindow.value), maxMode.value); }
      maxSlider.addEventListener("input", refreshMax);
      maxWindow.addEventListener("change", refreshMax);
      maxMode.addEventListener("change", refreshMax);
      [maxInterp, maxColor, maxOpacity, maxMin, maxMax, maxRadius, maxBlur]
        .forEach(el => el.addEventListener('input', refreshMax));
      // Manual date+time for maxima
      function setMaxFromDateTime() {
        const d = maxDate.value;
        const t = maxTime.value || "00:00";
        if (!d) return;
        const target = `${d}T${t}`;
        const idx = annualTimes.indexOf(target);
        if (idx !== -1) {
          maxSlider.value = idx;
          refreshMax();
        }
      }
      maxDate.addEventListener("change", setMaxFromDateTime);
      maxTime.addEventListener("change", setMaxFromDateTime);

      // --- Initial renders ---
      updateForecast(0);
      updateHistory(Number(historySlider.value));
      updateAnnual(Number(annualSlider.value));
      refreshMax();

      // --- Re-render Voronoi su move/zoom ---
      function reRenderOnMove(map, fn) {
        map.on('moveend', fn);
        map.on('zoomend', fn);
      }
      reRenderOnMove(mapForecast, () => {
        const ds = forecastDateStart.value, de = forecastDateEnd.value;
        if (ds && de) updateForecast(null, true);
        else updateForecast(Number(forecastSlider.value));
      });
      reRenderOnMove(mapHistory,  () => {
        const ds = historyDateStart.value, de = historyDateEnd.value;
        if (ds && de) updateHistory(null, true);
        else updateHistory(Number(historySlider.value));
      });
      reRenderOnMove(mapAnnual,   () => updateAnnual(Number(annualSlider.value)));
      reRenderOnMove(mapMaxima,   () => refreshMax());

      // --- Recap stazioni per anno (2022–2025) ---
      const recapContainer = document.getElementById("recapTables");
      const recapLoading = document.getElementById("recapLoading");
      const years = [2022, 2023, 2024, 2025];

      async function buildRecap() {
        let html = "";
        for (let name in locations) {
          const [lat, lon] = locations[name];
          const rows = [];
          for (let y of years) {
            try {
              const data = await fetchYearForLocation(lat, lon, y);
              const daily = data?.daily?.precipitation_sum || [];
              const dailyTime = data?.daily?.time || [];
              const hourly = data?.hourly?.precipitation || [];
              const hourlyTime = data?.hourly?.time || [];
              const total = daily.reduce((a,b)=>a+Number(b||0), 0);

              // Giorni piovosi
              const rainyDays = daily.reduce((a,b)=> a + (Number(b||0) > 0 ? 1 : 0), 0);

              // Arr orario numerico
              const arrH = hourly.map(x=>Number(x||0));
              const max1  = calcMaxWindowFull(arrH, 1);
              const max3  = calcMaxWindowFull(arrH, 3);
              const max6  = calcMaxWindowFull(arrH, 6);
              const max12 = calcMaxWindowFull(arrH, 12);
              const max24 = calcMaxWindowFull(arrH, 24);
              const max48 = calcMaxWindowFull(arrH, 48);
              const max72 = calcMaxWindowFull(arrH, 72);

              rows.push(`
                <tr>
                  <td>${y}</td>
                  <td>${fmt(total,1)}</td>
                  <td>${fmt(max1,1)}</td>
                  <td>${fmt(max3,1)}</td>
                  <td>${fmt(max6,1)}</td>
                  <td>${fmt(max12,1)}</td>
                  <td>${fmt(max24,1)}</td>
                  <td>${fmt(max48,1)}</td>
                  <td>${fmt(max72,1)}</td>
                  <td>${rainyDays}</td>
                </tr>
              `);
            } catch(e) {
              rows.push(`
                <tr>
                  <td>${y}</td><td colspan="9">Errore caricamento</td>
                </tr>
              `);
            }
          }

          html += `
            <div class="station-title">${name}</div>
            <table>
              <thead>
                <tr>
                  <th>Anno</th>
                  <th>Cumulata totale (mm)</th>
                  <th>Max 1h</th>
                  <th>Max 3h</th>
                  <th>Max 6h</th>
                  <th>Max 12h</th>
                  <th>Max 24h</th>
                  <th>Max 48h</th>
                  <th>Max 72h</th>
                  <th>Giorni piovosi</th>
                </tr>
              </thead>
              <tbody>
                ${rows.join('')}
              </tbody>
            </table>
          `;
        }
        recapContainer.innerHTML = html;
        recapLoading.style.display = "none";
      }

      buildRecap().catch(e => {
        console.error("Errore recap stazioni:", e);
        recapContainer.innerHTML = '<div class="error">Errore nel calcolo recap stazioni.</div>';
        recapLoading.style.display = "none";
      });
    }

    // Avvio
    loadAll().catch(e => {
      console.error("Errore generale caricamento dati:", e);
      document.getElementById("forecastLoading").innerHTML =
        '<div class="error">Errore nel caricamento previsioni. Controlla la console per dettagli.</div>';
      document.getElementById("historyLoading").innerHTML =
        '<div class="error">Errore nel caricamento storico. Controlla la console per dettagli.</div>';
    });
  </script>
</body>
</html>

